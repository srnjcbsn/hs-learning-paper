\documentclass[../Master.tex]{subfiles}
\providecommand{\master}{..}

\begin{document}

We will now explain how two hypergraphs describing patterns with the same effect can be combined into a single hypergraph. As before <binding section ref>, we wish to disprove that a certain binding is necessary for a conditional action to succeed. In the context of hypergraphs, this corresponds to removing vertices from binding edges

: Given two hyper graphs describing the same effect then  
If a vertex with name $p_i$ exists in only one of the binding edges, then the action have been applied successfully without the binding present, and it is as such disproven to be a precondition. It now holds that if removal of such a vertex causes the hyper graph to be disconnected, then components not connected to the hyper edge describing the effect can be disproven to be preconditions (by restriction~\ref{rst:ca:no-disjoint-preconditions}).

\begin{example} \label{ex:ca:hgma:disconnected}
	As an example of applying the hypergraph merging method described above, consider the following two patterns, described by hypergraphs $H_1$ and $H_2$, respectively (see \figref{fig:ex:ca:hgma:ex:disconnected}).
    \begin{equation*}
        H_1 = \forall x, y, z : q(x) \quad \text{when} \quad
            p(x,y) \land g(x, z)
    \end{equation*}

    \begin{equation*}
        H_2 = \forall \alpha, \beta : q(\alpha) \quad \text{when} \quad
            p(\alpha, \beta)
    \end{equation*}

	In this simple example, the first argument of predicate $g$ is bound to the first argument of the effect, but such a binding does not exist in $H_2$. Since the action succeeded without the binding, it can safely be discarded as a precondition and the merged hypergraph is now:

    \begin{equation*}
        H' = \forall x, y : q(x) \quad \text{when} \quad p(x, y)
    \end{equation*}

    \begin{figure}
        <placeholder>
        \caption{\label{fig:ex:ca:hgma:ex:disconnected} Figure of hypergraphs for example~\ref{ex:ca:hgma:disconnected}.}
    \end{figure}

    Note that the precondition decribed by $H_1$ is more restrictive than that of $H_2$. Consequentially, if $H_1$ was the real precondition, the conditional effect would not have succeeded for $H_2$.
\end{example}

The method of binding edge intersection described above can be applied recursively, starting with the binding edges containing the effects, continuing with binding edges connected by predicate edges to those vertices not removed not removed, and so on.

Although intersecting binding edges by vertex names is an appealing method, it is not always sufficient; if one of the hyper edges in question contains multiple vertices with the same name $p_i$ while the other contains one or more vertices with name $p_i$, then their intersection will yield a single vertex with that name. This is not always desirable, as bindings might be shadowed 

\begin{example} \label{ex:ca:hgma:generalization}
	Consider the application of an action $a$ in state $s_0$, producing the state $s_1$.

	\begin{equation*}
		s_0 = \left\{
			\begin{gathered}
				p(o_1, o_2), g(o_2), f(o_2), \\
				p(o_3, o_4), g(o_4), p(o_3, o_5), f(o_5)
			\end{gathered}
		\right\}
	\end{equation*}

	\begin{equation*}
		s_1 = s_0 \cup \left\{ q\left( o_1 \right), q \left( o_3 \right) \right\}
	\end{equation*}

	From inspecting the state transition, the following two patterns can be found:

    \begin{equation*}
        H_1 = \forall x, y : q(x) \quad \text{when} \quad
            p(x,y) \land f(y) \land g(y)
    \end{equation*}

    \begin{equation*}
        H_2 = \forall x, y, z : q(x) \quad \text{when} \quad
            p(x, y) \land p(x,z) \land f(y) \land g(z)
    \end{equation*}

	From these patterns, it is clear that $H_1$ is not the correct precondition, as it would have prevented the effect $q\left(o_3\right)$. However, $H_2$ is flexible enough to allow the effect $q\left(o_1\right)$ under the interpretation 
	\begin{equation*}
		x = o_1, y = z = o_2
	\end{equation*}

    \begin{figure}
        \centering
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \resizebox{\linewidth}{!}{\input{\master/Graphics/hgEx2_1.pgf}}
			\caption{$H_1$}
            \label{fig:ex:ca:hgma:ex:generalization1}
        \end{subfigure}%
        \hfill%
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \resizebox{0.8\linewidth}{!}{\input{\master/Graphics/hgEx2_2.pgf}}
            \caption{$H_2$}
            \label{fig:ex:ca:hgma:ex:generalization1}
        \end{subfigure}
		\caption{Hypergraphs for example~\ref{ex:ca:hgma:generalization}} 
    \end{figure}

\end{example}

\begin{definition}[Hyper edge intersection]
    The intersection of two hyper edges $e_1$ and $e_2$ is a new hyperedge where the number of vertices with name $v_i$ is equal to the number of vertices with name $v_i$ in $e_1$ and $e_2$, multiplied. Formally:
    \begin{equation*}
        e_1 \sqcap e_2 = \left\{
            f(v, t) \; | \;
                v \in e_1 \land t \in e_2 \land v \approx t
        \right\}
    \end{equation*}

    Here, $v \approx t$ is a special equality operator whih ignores vertex labels, such that $\left( n, p_i \right) \approx \left( m, q_i \right)$ iff $p_i = q_i$. $f$ is a function responsible for ass
\end{definition}

\begin{definition}
    Given two vertices with the same name, ie $v = \left(n, p_i \right)$ and $t = \left( m, p_i \right)$, $f(v,t)$ yields a new vertex with that name and an identifier based on $v$'s and $t$'s. $f$ must be injective, such that $f^{-1}(f(v,t)) = (v,t)$.
\end{definition}

 A simple implementation of $f$ is tupling the identifiers of the arguement, ie:

\begin{equation*}
    f\left( \left(n, p_i \right), \left(m, p_i \right) \right) =
        \left( (n,m), p_i \right)
\end{equation*}
Then, $f$ is clearly inversible, and $f^{-1}$ can be computed by tuple decomposition.

\begin{algorithm}
    \caption{Binding edge merging algorithm}
    \label{algo:bindingedgemerge}
    \begin{algorithmic}
        \Function {$\textsc{MergeBindingEdges}$} {$H_1, H_2, H', b_1, b_2$}
            \State $b' \gets b_1 \sqcap b_2$
            \State $H' \gets H' \cup b'$
            \ForAll {vertices $v \in b'$}
                \If {there is no predicate edge in $H'$ containing $v$}
                    \State $p_1 \gets$ predicate set in $H_1$ containing $f_1^{-1}(v)$
                    \State $p_2 \gets$ predicate set in $H_2$ containing $f_2^{-1}(v)$
                    \State $H' \gets \textsc{MergePredicateEdges}
                                        \left( H_1, H_2, H', p_1, p_2 \right)$
                \EndIf
            \EndFor
            \State \Return $H'$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Predicate edge merging algorithm}
    \label{algo:prededgemerge}

    \begin{algorithmic}
        \Function {$\textsc{MergePredicateEdges}$} {$H_1, H_2, H', p_1, p_2$}
            \State $p' \gets p_1 \sqcap p_2$
            \State $H' \gets H' \cup p'$
            \ForAll {vertices $v \in p'$}
                \If {there is no binding edge in $H'$ containing $v$}
                    \State $\left( v_1, v_2 \right) \gets f^-\left( v \right)$
                    % \State $\left( b_1, b_2 \right) \gets
                    %             \left(
                    %                 g\left( v_1, H_1 \right),
                    %                 g(\left( v_2, H_2 \right)
                    %             \right) $
                    \State $b_1 \gets$ the binding edge in $H_1$ containing $v_1$
                    \State $b_2 \gets$ the binding edge in $H_2$ containing $v_2$
                    \State $H' \gets \textsc{MergeBindingEdges}
                        \left( H_1, H_2, H', b_1, b_2 \right)$
                \EndIf
            \EndFor
            \State \Return $H'$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{Hyper graph merging algorithm}
    \label{algo:hypergraphmerge}
    \begin{algorithmic}
        \Function {$\textsc{MergeHyperGraphs}$} {$H_1$, $H_2$}
            \State Let $q_1$ and $q_2$ denote the predicate hyper edges describing the effect in $H_1$ and $H_2$, respectively
            \State Let $H' = \emptyset$ be a new, empty hyper graph
            \State $H' \gets \textsc{MergePredicateEdges}(H_1,H_2,H',q_1,q_2)$
            \State $H' \gets \textsc{CollapseHyperGraph}(H')$
            \State \Return $H'$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\end{document}
