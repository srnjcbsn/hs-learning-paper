\documentclass[../Master.tex]{subfiles}
\begin{document}
\providecommand{\master}{..}

Formerly we defined binding sets as a theoretical set, however for practical application we require an exact model.

For instance, earlier we made the assumption that ambiguous predicates would always match correctly, to get an idea of this problem
assume we have a precondition \{$p(x,y), p(z,x)$\}, if we designed the bindings as tuples $(p,(1,2),p)$ which is (predicate A, (variable position of A, variable position of B), predicate B).
Then as is evident this model will have two different interpretations either that there are two predicates like in our example or that there is one predicate with two bindings I.E. \{$p(x,x)$\}.
This could be solved by labeling each predicate with a number in no particular order  to indicate the origin predicate, thus $(p,(1,2),p)$ would become  $(p1,(1,2),p2)$ which would remove the dual interpretation.
However this creates a new issue: Since the numbering is non-deterministic another binding set might have used a different numbering for the predicates;
therefore without the assumption that the predicates always correctly match, meaning same numbering, two bindings that was equal could become be unequal. This becomes an issue with set intersection thus requiring us to redefine it.


This section will detail a new model for representing condition effects and bindings in particular, and it will explain how to utilize it for practical application of the theory.

To summarize the our prior model for preconditions and effects we have the four following sets.
\begin{description}
	\item [{Unproven~$B_u$}] The set of all bindings which has
	neither been proven nor disproven.
	\item [{Proven~$B_k$}] The set of all bindings which has been
	proven.
	\item [{Disproven~$B_d$}] Is the set of bindings and predicates which have
	been disproven, it can be derived from $B_d={\left( B_u \cup B_k \right)}^c$.
	\item [{Candidates~$B_c$}] Is a set of bindings where at least one of the bindings is an actual binding.
	This set like for non-conditional actions are used to prove bindings,
	which is accomplished through disproving the other candidates in the set.
\end{description}


	\subsection*{Hypergraph}
	As we have shown we need a model that represent different bindings over any number of predicates.
	Furthermore, it must provide support for multiple of the same predicates.

	For these reason we have designed a model for predicate bindings using hypergraphs;
	in this	model a vertex is a single predicate's variable position.
	For instance, if we modelled the following predicate $p(x,x)$ its vertices would be $p1$ and $p2$ because it contains two variables.
	The variables position is enumerated in sequence $1\ldots |p|$.

	<\texttt{TODO:} introduction to hypergraphs, edges are sets of vertices>

	In hypergraphs edges can be between more than 2 vertices, we use this to our advantage when modelling bindings.
	We can define two kinds of edges: one to combine predicate vertices into a single predicate and one to represent bindings.

	The two kinds of edges are defined as follows:


	\begin{description}
		\item [{Predicate~edge}] As  single predicates are represented as several vertices one for each variable
		it has; a number is used to indicate the order of the variable's
		positions. This number is appended to the label of the vertex. And an edge is used to connect these vertices together into a single predicate.
		We choose to visualize this type of edge with a line.\\
		\begin{tabular}{c  c}

			$p(x, y)$ becomes &
            \raisebox{-.5\height}{\resizebox{0.16\linewidth}{!}{\input{\master/Graphics/predicateEdge.pgf}}}
		\end{tabular}
		\item[{Binding edge}] To represent variables bound together through a common variable (Bindings) we
		choose to visualize this using normal cloud notation around them.\\
		\begin{tabular}{c  c}

			$p(x) \land q(x)$ becomes &
            \raisebox{-.5\height}{\resizebox{0.2\linewidth}{!}{\input{\master/Graphics/bindingEdge.pgf}}}
		\end{tabular}
	\end{description}

    A state can thus be represented as a hypergraph by converting each predicate to a set of vertices as described above, and collecting all vertices stemming from variables with the same name in binding edges. A detailed algorithm for this conversion is given in Section~\ref{sec:Impl:HGConstruction}, and an example is provided below.

% In addition to the above, a hypergraph also contains exactly one predicate edge which is labelled as the effect of the pattern the hypergraph describes (as a conditional effect can only have one effect, see~\ref{rst:ca:no-multiple-effect}).
%
% Note that a predicate edge will always contain a number of vertices equal to the arity of the predicate, while a binding edge can contain any number of vertices. Furthermore, a binding set can contain several vertices describing the same argument place of the same predicate. To discern vertices, we define them as a tuple containing a name denoting the predicate and the argument place it represents (such as $p_3$), as well as a unique identifier. 
%
% \begin{proposition}
%     All vertices in a hypergraph $H$ is member of exactly one predicate edge and one binding edge.
% \end{proposition}

\begin{figure}
    \centering
        \input{\master/Graphics/sokobanHyperGraph.pgf}
        \caption{Sokoban state from Example~\ref{ex:ca:sokoban-hypergraph} represented as a hypergraph. Here, $s = \texttt{sokobanAt}$, $adj = \texttt{hAdj}$ and $at = \texttt{at}$}\label{fig:ca:sokoban-hypergraph}
\end{figure}

\begin{example}\label{ex:ca:sokoban-hypergraph}
	Consider Example~\ref{ex:ca:sokoban-moveleft-action}. In this we had
	\begin{align*}
		\sigma(S_{before}, \delta) =
			\left\{
			\begin{gathered}
				\texttt{adj-h}(x, y), \\
				\texttt{adj-h}(y, z), \\
				\texttt{at}(y), \\
				\texttt{sokobanAt}(z)
			\end{gathered}
			\right\}
	\end{align*}
	When represented as a hypergraph (see \figref{fig:ca:sokoban-hypergraph}),
	we see that each binding is clearly visualized and that two of the same predicate (\texttt{adj-h}) can be in the same graph.
	Also by modelling this as a graph the idea of disproving bindings also
	becomes explicit as it literally means to remove a vertex from a binding edge.
	Furthermore, in this model the notion of disjoint predicates (Restriction~\ref{rst:ca:no-disjuntive-conditionals}) is shown by the vertices not being connected through any type of edge.
\end{example}

Consider again a state transition $\left( s, a, s' \right)$. The hypergraph constructed for $\ts(s)$ (as shown above) now describes how the predicates in $s$ are interconnected without mentioning specific objects or variables. Similarly, a single effect $p$ of action $a$ can be encoded as a hypergraph by the function $hypergraph(p,\ts(s))$, which constructs a hypergraph for $\ts(s) \cup \{p\}$, labelling the predicate edge describing $p$ as an effect.

Such a hypergraph describes which bindings were present in $\ts(s)$ when the effect $p$ occurred, and how $p$ is connected to them. In other words, it denotes the preconditions for the conditional that spawned $p$ which has not been disproven, and any binding \textit{not} in the hypergraph is disproven to be a precondition.

\begin{proposition}\label{prop:ca:singleConditional}
    Consider a state transition $\left(S, a, S'\right)$ and a grounded predicate $p \in \Delta S$. By Restrictions~\ref{rst:ca:no-disjuntive-conditionals} and~\ref{rst:ca:no-multiple-effect}, there is exactly one conditional in $A$ that could be responsible for producing $p$. 
\end{proposition}

\begin{proposition}
    For a state transition $\left( S, a, S' \right)$ and a predicate $p \in \Delta S$, any binding absent from $hypergraph \left( p, X(S) \right)$ is not a precondition for the conditional in $A$ with $p$ as effect. 
\end{proposition}

\begin{proof}[Proof by contradiction]
    Consider a state transition $\left( S, a, S' \right)$, a predicate $p \left( o_1 \right) \in \Delta S$, and the hypergraph $H = hypergraph\left( p\left(o_1\right), X(S) \right)$. If a binding $(p_1, q_1)$ is not present in $H$ (meaning that there is no binding edge in $H$ containing $p_1$ and $q_1$), then that binding is not present in $X(S)$ (i.e.\ $q\left(o_1\right) \notin S$). Thus, if that binding was a precondition for the conditional that spawned $p\left(o_1\right)$, then that interpretation of the conditional would have failed, and $p\left( o_1 \right)$ would not have occurred in $\Delta S$. Additionally, by Proposition~\ref{prop:ca:singleConditional}, no other conditional in $A$ could have caused the effect $p \left(o_1\right)$.
\end{proof}



Thus, a hypergraph constructed for the set $s \cup \{ p \}$ where $p \in \Delta \left(s, s' \right)$ describes which bindings were present in $s$ when the effect $p$ occurred, and how $p$ are connected to them. In other words, such a hypergraph denotes the preconditions for the conditional that spawned $p$ which has not been disproven (since any binding absent from the hypergraph can not be a precondition, as it would have caused the conditional to fail in the interpretation that spawned $p$). To discern the predicate edge denoting $p$, it is explicitly labelled as an effect. If a hypergraph is constructed for the set $s \cup \{ q \}$ where $q \in \Delta \left(s,s'\right)$ is a predicate with the same name as $p$ but with different objects as arguments, it represents the preconditions observed for another interpretation of the conditional. Since both hypergraphs describe binding preconditions for the same conditional (under different interpretations), bindings that are absent from either of them can not be a precondition for that conditional. Thus, if the two hypergraphs can be merged into one which only contains bindings they have in common, then any binding absent from the newly formed hyper graph can not be preconditions of the conditional either. Such a merging algorithm is described in Section~\ref{sec:C:HGMerging}.

From the above, it follows that all grounded predicates with name $n$ in $\Delta\left(s, s'\right)$ can be merged together to disprove preconditions of the conditional that spawned them. The resulting hypergraph then constitutes all bindings that have not explicitly been disproven to be predicates, and can as such be reused in for another transition.

\begin{equation*}
    reduce(c, H) =
    \left\{ \left( t_1, t_2 \right) \mid 
        \left( t_1, t_2 \right) \in c \land 
        \exists_{b \in H} \left[ t_1 \in b \land t_2 \in b \right] 
    \right\}
\end{equation*}

\begin{algorithm}
    \caption{Algorithm for learning conditional effects using hypergraphs}\label{algo:CondEffLearn}
    \begin{algorithmic}
        \Function{Update-Knowledge}{$n$, $\Delta s$, $U$, $K$, $C$}
            \ForAll{predicates $p \in \Delta s$ with name $n$}
                \State{$H_p \gets hypergraph(p, s)$}
                \State{$\left(U, r \right) \gets merge \left( U, H_p \right)$}
                \State{$\left( C, K \right) \gets rename(r, C, K)$}
            \EndFor
            \ForAll{predicates $q \notin \Delta s$ with name $n$}
                \State{$H_q \gets hypergraph(q, s)$}
                \State{$C_n \gets C_n \cup cands\left( H_q, U \right)$}
            \EndFor
            \State{$C_n = \left\{ reduce\left(c, U\right) \mid c \in C_n \right\}$}
            \State{Remove any singleton sets from $C_n$, and add them to $K_n$}
        \EndFunction

        \Function{$\textsc{Conditional-Effect-Learn}$} {$\left( s, a, s'\right)$, $U$, $K$, $C$}
            \ForAll{predicate names $n$}
                \State{$UpdateKnowledge\left(n, \Delta s, U_n, K_n, C_n \right)$}
            \EndFor
        \EndFunction%
    \end{algorithmic}
\end{algorithm}

\end{document}
